/*
 * This is needed by edge.js

#r "C:\Program Files\Hewlett-Packard\Sprout\SDK\HP.PC.Presentation.dll"
#r "lib\PresentationCore.dll"
#r "lib\WindowsBase.dll"
#r "lib\System.Xaml.dll"
 */
using System.Threading.Tasks;
using HP.PC.Presentation;
using System;
using System.Diagnostics;
using System.Windows.Media.Imaging;
using System.Linq;
using System.IO;
using System.Globalization;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace MerlinJSBinding
{
    public class Merlin
    {
        Func<object, Task<object>> trackingHandlerCallback;
		private IPcObjectTrackingHandler trackingHandler;
		private List<PcTrainingImage> trainingImages;
        private static IPcLink pcLink;
        private static IPcLink PcLink
        {
            get
            {
                pcLink = (pcLink ?? HPPC.CreateLink());
                return pcLink;
            }
        }
		
		private static IDictionary<Guid, IPcMoment> pcMoments = new Dictionary<Guid, IPcMoment>();
        private static IDictionary<Guid, IPcMoment> PcMoments
        {
            get
            {
                return pcMoments;
            }
        }


        public async Task<object> Execute(dynamic input)
        {
            
            string commandName = (string)input.commandName;
            if (commandName == null)
            {
                throw new Exception("'commandName' is a required input");
            }
            try
            {
                switch(commandName)
                {
                    case "capture":
                        return await CaptureMoment(input);
                    case "captureFromFile":
                        return await CaptureMomentFromFile(input);
                    case "extractPicture":
                        return await ExtractPicture(input);
                    case "extractPreview":
                        return await ExtractPreview(input);
                    case "extractOutline":
                        return await ExtractOutline(input);
                    case "extractText":
                        return await ExtractText(input);
                    case "showKeyboard":
                        return await ShowKeyboard(input);
					case "disposeMoment":
                        return await DisposeMoment(input);
					case "disposePcLink":
                        return await DisposePcLink();
                    case "createTrackingHandler":
                        return await CreateTrackingHandler(input);
                    case "disposeTrackingHandler":
                        return await DisposeTrackingHandler(input);
                    case "initializeObjectTracker":
                        return await InitializeObjectTracker(input);
                    case "addTrainingImages":
                        return await AddTrainingImages(input);
                    case "startTracking":
                        return await StartTracking(input);
                    case "stopTracking":
                        return await StopTracking(input);
						
                }				
            }
            catch (Exception e)
            {
                throw new Exception(e.Message);
            }
            return null;
        }

        private async Task<object> CaptureMoment(dynamic input)
        {
		Logger("Hello World");
            IPcMoment moment = await PcLink.CaptureMomentAsync();
			pcMoments.Add(moment.Identifier, moment);
            return moment.Identifier.ToString();
        }

        private async Task<object> CaptureMomentFromFile(dynamic input)
        {
            string imageURI = (string)input.imageURI;
            if (imageURI == null)
            {
                throw new Exception("Please specify an image URL");
            }
            BitmapSource bitmapImage = null;
            bitmapImage = new BitmapImage(new Uri(imageURI, UriKind.RelativeOrAbsolute));
            
            if (bitmapImage == null)
            {
                throw new Exception("Invalid image file");
            }
            IPcMoment moment = await PcLink.CaptureMomentAsync(bitmapImage);
			pcMoments.Add(moment.Identifier, moment);
            return moment.Identifier.ToString();
        }

        private async Task<object> ExtractPicture(dynamic input)
        {
            IPcPicture picture = await PcLink.ExtractPictureAsync(getMoment((string)input.momentId));
            return new { picture = ConvertIPcPicture(picture) };
        }

        private async Task<object> ExtractPreview(dynamic input)
        {
            IPcSpecification spec = await PcLink.AccessSpecificationAsync();
            IPcPicture picture = await PcLink.ExtractPictureAsync(getMoment((string)input.momentId), spec.Picture.Extract.Mat);
            return new { picture = ConvertIPcPicture(picture) };
        }
         

        private async Task<object> ExtractOutline(dynamic input)
        {
            IPcOutline outline = await PcLink.ExtractOutlineAsync(getMoment((string)input.momentId));
            return new { outline = ConvertIPcOutline(outline) };
        }

        private async Task<object> ExtractText(dynamic input)
        {
            IPcText text = await PcLink.ExtractTextAsync(getMoment((string)input.momentId));
            return new { text = ConvertIPcText(text) };
        }
		
		public void Logger(String lines)
		{

		 // Write the string to a file.append mode is enabled so that the log
		 // lines get appended to  test.txt than wiping content and writing the log

		  //System.IO.StreamWriter file = new System.IO.StreamWriter("c:\\Temp\\test.txt",true);
		  //file.WriteLine(DateTime.Now.ToString("dd-MM-yyyy-hh-mm-ss") + " " + lines);

		  //file.Close();

		}

        private async Task<object> InitializeObjectTracker(dynamic input)
        {
			trainingImages = new List<PcTrainingImage>();
			return true;
		}
		
		private async Task<object> AddTrainingImages(dynamic input)
        {
			string name = (string)input.name;
			IPcPicture picture = await PcLink.ExtractPictureAsync(getMoment((string)input.momentId));
			for (int i = 0; i < picture.Children.Count(); i++)
			{
				PcTrainingImage trainingImage = new PcTrainingImage(name + i, picture.Children.ElementAt(i).Image);
				trainingImages.Add(trainingImage);
			}
			return true;
		}
		
		private async Task<object> StartTracking(dynamic input)
        {
			trackingHandlerCallback = (Func<object, Task<object>>)input.callback;
            if (trackingHandlerCallback == null)
            {
                throw new Exception("no callback function is provided");
            }
			trackingHandler = PcLink.CreateObjectTrackingHandler(trainingImages);
			
			
			// Subscribe to object-tracking events.
			trackingHandler.TrackUpdated += _imagesTrackHandler_TrackUpdated;
			Logger("Before start");
			// Start object tracking.
			trackingHandler.StartAsync().Wait();
            Logger("After start");
			return true;
		}
		
		private async Task<object> StopTracking(dynamic input)
        {
			try
            {
                await StopImageTracking();
                return true;
            }
            catch (Exception e)
            {
                throw;
            }
		}
		
        private async Task<object> CreateTrackingHandler(dynamic input)
        {
			Logger("Start Image Tracking");
            trackingHandlerCallback = (Func<object, Task<object>>)input.callback;
            if (trackingHandlerCallback == null)
            {
                throw new Exception("no callback function is provided");
            }
			
			IPcMoment moment = await PcLink.CaptureMomentAsync();
			
			// Extract the top-level picture and child images.
			var picture = await PcLink.ExtractPictureAsync(moment);

			// Extract the top-level outline and child outlines.
			var outline = await PcLink.ExtractOutlineAsync(moment);
			
			//var combolist = new List<TrackingHandlerDataObject>();
			List<PcTrainingImage> images = new List<PcTrainingImage>();
			Logger(picture.Children.Count().ToString());
			for (int i = 0; i < picture.Children.Count(); i++)
			{
				PcTrainingImage trainingImage = new PcTrainingImage("Object " + i, picture.Children.ElementAt(i).Image);
				images.Add(trainingImage);
			}

			// Create the object-tracking handler.
			trackingHandler = PcLink.CreateObjectTrackingHandler(images);
			
			// Subscribe to object-tracking events.
			trackingHandler.TrackUpdated += _imagesTrackHandler_TrackUpdated;
			Logger("Before start");
			// Start object tracking.
			trackingHandler.StartAsync().Wait();
            Logger("After start");
            
            return true;
        }

        private async Task<object> DisposeTrackingHandler(dynamic input)
        {
            try
            {
                await StopImageTracking();
                return true;
            }
            catch (Exception e)
            {
                throw;
            }
        }
        
        private async Task<object> ShowKeyboard(dynamic input)
        {
            string arg = (input.show == "true") ? @"/event:show" : @"/event:quit";

            var pl = "./node_modules/merlin/lib";
            var pi = new ProcessStartInfo
            {
                WindowStyle = ProcessWindowStyle.Hidden,
                WorkingDirectory = pl,
                FileName = System.IO.Path.Combine(pl, "userinput.exe"),
                UseShellExecute = false,
                Arguments = arg
            };
            Process.Start(pi);

            return true;
        }
		
		private async Task<object> DisposeMoment(dynamic input)
        {
            try
            {
                var momentId = (string)input.momentId;
                getMoment(momentId).Dispose();
				pcMoments.Remove(Guid.Parse(momentId));
				System.GC.Collect();
            }
            catch (Exception e)
            {
                throw new Exception(e.Message);
            }
            return pcMoments.Count;
        }


        public IPcMoment getMoment(String id)
        {
            return PcMoments[Guid.Parse(id)];
        }

        public async Task<object> DisposePcLink()
        {
            PcLink.Dispose();
            pcLink = null;
            return true;
        }


        /*private object ConvertIPcPicture(IPcPicture picture)
        {
            var result = new
            {
                Image = ConvertToBase64(picture.Image),
                Children = (from c in picture.Children select ConvertIPcPicture(c)).ToArray(),
                PhysicalBoundaries = picture.PhysicalBoundaries,
                PixelDensity = picture.PixelDensity,
                SkewAngle = double.IsNaN(picture.SkewAngle) ? 0.0 : picture.SkewAngle
            };
            return result;
        }*/

        //todo: move to a different class
        private object ConvertIPcPicture(IPcPicture picture)
        {
            var result = new
            {
                //Image = SaveImage(picture.Image),
                Image = ConvertToBase64(picture.Image),
                Children = (from c in picture.Children select ConvertIPcPicture(c)).ToArray(),
                PhysicalBoundaries = picture.PhysicalBoundaries,
                PixelDensity = picture.PixelDensity,
                SkewAngle = double.IsNaN(picture.SkewAngle) ? 0.0 : picture.SkewAngle
            };
            return result;
        }

        private string SaveImage(BitmapSource bitmap)
        {
            var imagePath = Path.GetTempFileName();
            var encoder = new PngBitmapEncoder();
            var frame = BitmapFrame.Create(bitmap);
            encoder.Frames.Add(frame);
            using (var stream = System.IO.File.OpenWrite(imagePath))
            {
                encoder.Save(stream);
            }
            Console.WriteLine(imagePath);
            return imagePath;
        }


        private object ConvertIPcOutline(IPcOutline outline)
        {
            var result = new
            {
                Children = (from c in outline.Children select ConvertIPcOutline(c)).ToArray(),
                Contour = outline.Contour.ToString(CultureInfo.InvariantCulture),
                PhysicalBoundaries = outline.PhysicalBoundaries,
                PixelDensity = outline.PixelDensity,                
                SkewAngle = double.IsNaN(outline.SkewAngle) ? 0.0 : outline.SkewAngle
            };
            return result;
        }


        private object ConvertIPcText(IPcText text)
        {
            var result = new
            {
                Children = (from c in text.Children select ConvertIPcText(c)).ToArray(),
                PhysicalBoundaries = text.PhysicalBoundaries,
                Text = text.Text
            };
            return result;
        }

        private string ConvertToBase64(BitmapSource bitmap)
        {
            MemoryStream ms = new MemoryStream();
            PngBitmapEncoder encoder = new PngBitmapEncoder();
            encoder.Frames.Add(BitmapFrame.Create(bitmap));
            encoder.Save(ms);
            return Convert.ToBase64String(ms.ToArray());
        }
		
		void _imagesTrackHandler_TrackUpdated(object sender, PcTrackEventArgs e)
        {
			Logger("detected: " + e);
            //call javascript method
            trackingHandlerCallback(e);
			
        }
		
		private async Task<object> StopImageTracking()
        {
			Logger("Stopping Image Tracking");

            if (trackingHandler != null)
            {
                await trackingHandler.StopAsync();

                trackingHandler.TrackUpdated -= _imagesTrackHandler_TrackUpdated;
                trackingHandler.Dispose();
                trackingHandler = null;
                return true;
            }
            else
            {
                throw new Exception("Tracking was not started.");
            }
        }
    }
}